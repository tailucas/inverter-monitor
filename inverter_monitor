#!/usr/bin/env python
import logging.handlers

import binascii
import builtins
import libscrc
import re
import requests
import simplejson as json
import socket
import threading
import time
import zmq

import paho.mqtt.client as mqtt
from paho.mqtt.client import MQTT_ERR_NO_CONN

from pathlib import Path
from simplejson.scanner import JSONDecodeError
from zmq.error import ZMQError, ContextTerminated

import os.path

# setup builtins used by pylib init
app_name = Path(__file__).stem
builtins.APP_NAME = app_name
builtins.SENTRY_EXTRAS = []
influx_creds_section = 'local'


class CredsConfig:
    sentry_dsn: f'opitem:"Sentry" opfield:{app_name}.dsn' = None  # type: ignore
    cronitor_token: f'opitem:"cronitor" opfield:.password' = None  # type: ignore
    influxdb_org: f'opitem:"InfluxDB" opfield:{influx_creds_section}.org' = None  # type: ignore
    influxdb_token: f'opitem:"InfluxDB" opfield:{influx_creds_section}.token' = None  # type: ignore
    influxdb_url: f'opitem:"InfluxDB" opfield:{influx_creds_section}.url' = None  # type: ignore
    weather_api_key: f'opitem:"OpenWeather" opfield:.password' = None  # type: ignore


# instantiate class
builtins.creds_config = CredsConfig()

from lib import app_config, \
    creds, \
    device_name_base, \
    log

from lib.process import SignalHandler
from lib import threads
from lib.threads import thread_nanny
from lib.app import AppThread
from lib.zmq import zmq_term, Closable
from lib.handler import exception_handler

from requests.adapters import ConnectionError
from requests.exceptions import RequestException

from influxdb_client import InfluxDBClient, Point
from influxdb_client.client.write_api import ASYNCHRONOUS


URL_WORKER_APP = 'inproc://app-worker'
URL_WORKER_MQTT_PUBLISH = 'inproc://mqtt-publish'


DEFAULT_SAMPLE_INTERVAL_SECONDS = 60
ERROR_RETRY_INTERVAL_SECONDS = 5
IMPLAUSIBLE_CHANGE_PERCENTAGE = 10


def twos_complement_hex(hexval):
    bits = 16
    val = int(hexval, bits)
    if val & (1 << (bits-1)):
        val -= 1 << bits
    return val


class LoggerReader(AppThread, Closable):

    def __init__(self, field_mappings, logger_sn, logger_ip, logger_port, sample_interval_secs=DEFAULT_SAMPLE_INTERVAL_SECONDS):
        AppThread.__init__(self, name=self.__class__.__name__)
        Closable.__init__(self)

        self.processor = self.get_socket(zmq.PUSH)

        self.field_mappings = field_mappings
        self.logger_sn = logger_sn
        self.logger_ip = logger_ip
        self.logger_port = logger_port
        self.sample_interval_secs = sample_interval_secs

    def get_logger_data(self):
        output = {}

        client_socket = None
        pini = 59
        pfin = 112
        chunks = 0
        while chunks < 2:
            start = binascii.unhexlify('A5')  # start
            length = binascii.unhexlify('1700')  # datalength
            controlcode = binascii.unhexlify('1045')  # controlCode
            serial = binascii.unhexlify('0000')  # serial
            datafield = binascii.unhexlify('020000000000000000000000000000')  # com.igen.localmode.dy.instruction.send.SendDataField
            pos_ini = str(hex(pini)[2:4].zfill(4))
            pos_fin = str(hex(pfin-pini+1)[2:4].zfill(4))
            businessfield = binascii.unhexlify('0103' + pos_ini + pos_fin)  # sin CRC16MODBUS
            crc = binascii.unhexlify(str(hex(libscrc.modbus(businessfield))[4:6])+str(hex(libscrc.modbus(businessfield))[2:4]))  # CRC16modbus
            checksum = binascii.unhexlify('00')  # checksum F2
            endCode = binascii.unhexlify('15')

            inverter_sn2 = bytearray.fromhex(hex(self.logger_sn)[8:10] + hex(self.logger_sn)[6:8] + hex(self.logger_sn)[4:6] + hex(self.logger_sn)[2:4])
            frame = bytearray(start + length + controlcode + serial + inverter_sn2 + datafield + businessfield + crc + checksum + endCode)

            checksum = 0
            frame_bytes = bytearray(frame)
            for i in range(1, len(frame_bytes) - 2, 1):
                checksum += frame_bytes[i] & 255
            frame_bytes[len(frame_bytes) - 2] = int((checksum & 255))

            # OPEN SOCKET

            for res in socket.getaddrinfo(self.logger_ip, self.logger_port, socket.AF_INET, socket.SOCK_STREAM):
                family, socktype, proto, canonname, sockadress = res
                try:
                    client_socket = socket.socket(family,socktype,proto)
                    client_socket.settimeout(10)
                    client_socket.connect(sockadress)
                except socket.error as msg:
                    log.warning(f'{msg}')
                    return None

            # SEND DATA
            client_socket.sendall(frame_bytes)

            # RECEIVE RESPONSE
            data = None
            try:
                data = client_socket.recv(1024)
                if data is None:
                    log.warning(f'No response data.')
                    return None
            except socket.timeout as msg:
                log.warning(f'{msg}')
                return None
            finally:
                try:
                    client_socket.close()
                except socket.error as msg:
                    log.warning(f'{msg}')

            # PARSE RESPONSE (start position 56, end position 60)
            totalpower = 0
            i = pfin - pini
            a = 0
            while a <= i:
                p1 = 56+(a*4)
                p2 = 60+(a*4)
                try:
                    response = twos_complement_hex(str(''.join(hex(ord(chr(x)))[2:].zfill(2) for x in bytearray(data))+'  '+re.sub('[^\x20-\x7f]', '', ''))[p1:p2])
                except ValueError:
                    log.warning(f'Discarding {len(data)} byte response.', exc_info=True)
                    return None
                hexpos = str("0x") + str(hex(a+pini)[2:].zfill(4)).upper()
                for parameter in self.field_mappings:
                    for item in parameter["items"]:
                        title = item["titleEN"]
                        ratio = item["ratio"]
                        unit = item["unit"]
                        for register in item["registers"]:
                            if register == hexpos and chunks != -1:
                                if title.find("Temperature") != -1:
                                    response = round(response * ratio-100, 2)
                                else:
                                    response = round(response * ratio, 2)
                                if len(unit) > 0:
                                    key = f'{title} {unit}'
                                else:
                                    key = f'{title}'
                                # sanitize string
                                key = key.replace(' ','_').replace('-','_').replace('ยบ','c').replace('%','pct').lower()
                                output[key] = response
                                if hexpos == '0x00BA':
                                    totalpower += response * ratio
                                if hexpos == '0x00BB':
                                    totalpower += response * ratio
                a+=1
            pini=150
            pfin=195
            chunks+=1
        return output

    # noinspection PyBroadException
    def run(self):
        self.processor.connect(URL_WORKER_APP)
        with exception_handler(closable=self):
            prev_battery_soc = None
            while not threads.shutting_down:
                operation_start_time = time.time()
                tries = 1
                logger_data = None
                while time.time() - operation_start_time < DEFAULT_SAMPLE_INTERVAL_SECONDS/2:
                    tries += 1
                    logger_data = self.get_logger_data()
                    if isinstance(logger_data, dict):
                        if 'battery_soc_pct' in logger_data.keys():
                            battery_soc = logger_data['battery_soc_pct']
                            if prev_battery_soc is None:
                                prev_battery_soc = battery_soc
                                # dict is good enough
                                break
                            soc_variance_pct = int(abs(((prev_battery_soc-battery_soc) / prev_battery_soc)) * 100)
                            log.debug(f'battery_soc_pct changed by {soc_variance_pct}% from {prev_battery_soc} to {battery_soc}.')
                            if soc_variance_pct >= IMPLAUSIBLE_CHANGE_PERCENTAGE:
                                log.warning(f'battery_soc_pct changed by more than {IMPLAUSIBLE_CHANGE_PERCENTAGE}% from {prev_battery_soc} to {battery_soc}. Treating this output as implausible: {str(logger_data)}')
                            else:
                                # accept the new value as good
                                prev_battery_soc = battery_soc
                                # control field change is plausible
                                break
                    log.warning(f'Waiting {ERROR_RETRY_INTERVAL_SECONDS}s after {tries} unsuccessful tries.')
                    threads.interruptable_sleep.wait(ERROR_RETRY_INTERVAL_SECONDS)
                if logger_data is not None and len(logger_data) > 0:
                    log.debug(f'Sending {len(logger_data)} fields for publication.')
                    self.processor.send_pyobj({'inverter': logger_data})
                else:
                    log.error(f'Unable to fetch any valid data after {tries} tries (within {DEFAULT_SAMPLE_INTERVAL_SECONDS}s).')
                # stop for the remainder of the sampling interval
                operation_time = time.time() - operation_start_time
                sample_delay = self.sample_interval_secs - operation_time
                if sample_delay < 0:
                    normalized_sample_delay = min(operation_time, self.sample_interval_secs)
                    log.warning(f'Sample interval of {self.sample_interval_secs}s is too short, implying wait of {sample_delay:.2f}s. Resetting delay to {normalized_sample_delay:.2f}s.')
                    # don't use 0: never spin
                    sample_delay = normalized_sample_delay
                log.debug(f'Waiting {sample_delay:.2f}s until the next sample.')
                threads.interruptable_sleep.wait(sample_delay)


class WeatherReader(AppThread, Closable):

    def __init__(self):
        AppThread.__init__(self, name=self.__class__.__name__)
        Closable.__init__(self)

        self.processor = self.get_socket(zmq.PUSH)

        self.api_key = creds.weather_api_key
        self.lat, self.lon = tuple(app_config.get('weather', 'coord_lat_lon').split(','))

    def get_weather_data(self):
        output = None
        try:
            r = requests.get('https://api.openweathermap.org/data/2.5/weather', params={
                'lat': self.lat,
                'lon': self.lon,
                'appid': self.api_key,
            })
            try:
                output = json.loads(r.content)
                log.debug(f'Loaded {len(output)} weather fields.')
            except JSONDecodeError:
                log.exception(f'JSON parse error of {r.content}')
                return None
        except (OSError, ConnectionError, RequestException):
            log.exception('Problem getting weather data.')
            return None
        return output

    # noinspection PyBroadException
    def run(self):
        log.info(f'Fetching weather data using coordinates [{self.lat},{self.lon}].')
        self.processor.connect(URL_WORKER_APP)
        with exception_handler(closable=self):
            while not threads.shutting_down:
                wd = self.get_weather_data()
                log.debug(f'Received weather data: {wd}')
                if wd is not None and len(wd) > 0:
                    weather = dict()
                    weather['cloudiness_pct'] = wd['clouds']['all']
                    date_value = int(wd['dt'])
                    sunrise = int(wd['sys']['sunrise'])
                    sunset = int(wd['sys']['sunset'])
                    sun_output = 0
                    # calculate theoretical sun output
                    if date_value > sunrise and date_value < sunset:
                        # normalize and divide
                        midday_secs = (sunset - sunrise) / 2
                        secs_from_dark = min(date_value - sunrise, sunset - date_value)
                        sun_output = (secs_from_dark / midday_secs) * 100
                    country = wd['sys']['country']
                    weather['midday_pct'] = sun_output
                    log.debug(f'{country}: Sending {len(weather)} fields for publication: {weather}')
                    self.processor.send_pyobj({'weather': weather})
                threads.interruptable_sleep.wait(DEFAULT_SAMPLE_INTERVAL_SECONDS)


class MqttSubscriber(AppThread, Closable):

    def __init__(self, mqtt_server_address, mqtt_topic_prefix):
        AppThread.__init__(self, name=self.__class__.__name__)
        Closable.__init__(self, connect_url=URL_WORKER_MQTT_PUBLISH)

        self.processor = self.get_socket(zmq.PUSH)

        self._mqtt_client = None
        self._mqtt_server_address = mqtt_server_address
        self._mqtt_subscribe_topic_prefix = mqtt_topic_prefix

        self._disconnected = False

        self._topic_state = dict()

    def close(self):
        Closable.close(self)
        try:
            self._mqtt_client.disconnect()
        except Exception:
            log.warning('Ignoring error closing MQTT socket.', exc_info=True)

    def on_connect(self, client, userdata, flags, rc):
        subscription_topic = f'{self._mqtt_subscribe_topic_prefix}/#'
        log.info(f'Subscribing to topic [{subscription_topic}]...')
        self._mqtt_client.subscribe(subscription_topic)

    def on_disconnect(self, client, userdata, rc):
        log.info('MQTT client has disconnected.')
        self._disconnected = True

    def on_message(self, client, userdata, msg):
        topic = msg.topic
        payload = msg.payload
        log.debug(f'{topic} received {len(payload)} bytes.')
        msg_data = None
        try:
            log.debug(f'{topic} received: {payload}')
            msg_data = json.loads(payload)
        except JSONDecodeError:
            log.exception(f'Unstructured message: {payload}')
            return
        except ContextTerminated:
            self.close()
        if 'switches' in msg_data.keys():
            new_state = msg_data['switches']
            old_state = list()
            if topic in self._topic_state:
                old_state = self._topic_state[topic]
            if new_state != old_state:
                for ids, s in enumerate(new_state):
                    log.info(f'Switch {ids+1} is now in state [{s}]')
            # state capture
            self._topic_state[topic] = new_state

    # noinspection PyBroadException
    def run(self):
        self.processor.connect(URL_WORKER_APP)
        log.info(f'Connecting to MQTT server {self._mqtt_server_address}...')
        self._mqtt_client = mqtt.Client()
        self._mqtt_client.on_connect = self.on_connect
        self._mqtt_client.on_disconnect = self.on_disconnect
        self._mqtt_client.on_message = self.on_message
        self._mqtt_client.connect(self._mqtt_server_address)
        with exception_handler(closable=self, and_raise=False, shutdown_on_error=True):
            while not threads.shutting_down:
                rc = self._mqtt_client.loop()
                if rc == MQTT_ERR_NO_CONN or self._disconnected:
                    raise ResourceWarning(f'No connection to MQTT broker at {self._mqtt_server_address} (disconnected? {self._disconnected})')
                # check for messages to publish
                try:
                    mqtt_pub_topic, message_data = self.socket.recv_pyobj(flags=zmq.NOBLOCK)
                    log.debug(f'Publishing {len(message_data)} bytes to topic {mqtt_pub_topic}...')
                    self._mqtt_client.publish(topic=mqtt_pub_topic, payload=message_data)
                except ZMQError:
                    # ignore, no data
                    pass


class EventProcessor(AppThread, Closable):

    def __init__(self):
        AppThread.__init__(self, name=self.__class__.__name__)
        Closable.__init__(self, connect_url=URL_WORKER_APP)

        self.influxdb_bucket = app_config.get('influxdb', 'bucket')

        self.influxdb = None
        self.influxdb_rw = None
        self.influxdb_ro = None

        self._mqtt_socket = self.get_socket(zmq.PUSH)

    def _influxdb_write(self, point_name, field_name, field_value):
        try:
            self.influxdb_rw.write(
                bucket=self.influxdb_bucket,
                record=Point(point_name).tag("application", app_name).tag("device", device_name_base).field(field_name, field_value))
        except Exception:
            log.warning(f'Unable to post to InfluxDB.', exc_info=True)

    # noinspection PyBroadException
    def run(self):
        self._mqtt_socket.connect(URL_WORKER_MQTT_PUBLISH)
        # influx DB
        log.info(f'Connecting to InfluxDB at {creds.influxdb_url} using bucket {self.influxdb_bucket}.')
        self.influxdb = InfluxDBClient(
            url=creds.influxdb_url,
            token=creds.influxdb_token,
            org=creds.influxdb_org)
        self.influxdb_rw = self.influxdb.write_api(write_options=ASYNCHRONOUS)
        self.influxdb_ro = self.influxdb.query_api()
        with exception_handler(closable=self, and_raise=False, shutdown_on_error=True):
            while not threads.shutting_down:
                event = self.socket.recv_pyobj()
                log.debug(event)
                # DEBUG
                switch_state = 1
                if isinstance(event, dict):
                    for point_name in list(event):
                        point_items = event[point_name]
                        for key, value in point_items.items():
                            if key == 'grid_voltage_l1_v' and int(value) < 200:
                                switch_state = 0
                                log.debug(f'Set switch control state to {switch_state}.')
                            self._influxdb_write(point_name, key, value)
                        log.debug(f'Wrote {len(point_items)} {point_name} points.')
                log.debug(f'Sending switch control message.')
                self._mqtt_socket.send_pyobj((
                    'switches/switch1/control',
                    json.dumps(
                        {'switches': [{"switch": 0, "state": switch_state},
                                      {"switch": 1, "state": switch_state}]}
                    )
                ))


if __name__ == "__main__":
    log.setLevel(logging.INFO)
    # load basic configuration
    mappings = None
    mappings_file = ''.join([os.path.join(APP_PATH, 'config', 'field_mappings.txt')])  # type: ignore
    with open(mappings_file) as mapping_file:
        try:
            mappings = json.loads(mapping_file.read())
            log.info(f'Loaded {len(mappings)} field mappings from {mappings_file}')
        except JSONDecodeError as e:
            log.exception(f'Error loading {mappings_file}.')
            raise e
    # ensure proper signal handling; must be main thread
    signal_handler = SignalHandler()
    event_processor = EventProcessor()
    logger_reader = LoggerReader(
        field_mappings=mappings,
        logger_sn=app_config.getint('inverter', 'logger_sn'),
        logger_ip=app_config.get('inverter', 'logger_address'),
        logger_port=app_config.getint('inverter', 'logger_port'),
        sample_interval_secs=app_config.getint('inverter', 'logger_sample_interval_seconds'))
    weather_reader = WeatherReader()
    mqtt_subscriber = MqttSubscriber(
        mqtt_server_address=app_config.get('mqtt', 'server_address'),
        mqtt_topic_prefix=app_config.get('mqtt', 'topic_prefix'))
    nanny = threading.Thread(
        name='nanny',
        target=thread_nanny,
        args=(signal_handler,),
        daemon=True)
    # startup completed
    # back to INFO logging
    log.setLevel(logging.INFO)
    try:
        log.info('Starting application threads...')
        event_processor.start()
        logger_reader.start()
        weather_reader.start()
        mqtt_subscriber.start()
        # start thread nanny
        nanny.start()
        log.info('Startup complete.')
        # hang around until something goes wrong
        threads.interruptable_sleep.wait()
        raise RuntimeWarning("Shutting down...")
    except(KeyboardInterrupt, RuntimeWarning, ContextTerminated) as e:
        log.warning(str(e))
        threads.shutting_down = True
        threads.interruptable_sleep.set()
    finally:
        zmq_term()
    log.info('Shutdown complete.')

#!/usr/bin/env python
import logging.handlers

import binascii
import builtins
import libscrc
import re
import requests
import simplejson as json
import socket
import threading
import time
import zmq

from pathlib import Path
from simplejson.scanner import JSONDecodeError
from zmq.error import ContextTerminated

import os.path

# setup builtins used by pylib init
app_name = Path(__file__).stem
builtins.APP_NAME = app_name
builtins.SENTRY_EXTRAS = []
influx_creds_section = 'local'


class CredsConfig:
    sentry_dsn: f'opitem:"Sentry" opfield:{app_name}.dsn' = None  # type: ignore
    cronitor_token: f'opitem:"cronitor" opfield:.password' = None  # type: ignore
    influxdb_org: f'opitem:"InfluxDB" opfield:{influx_creds_section}.org' = None  # type: ignore
    influxdb_token: f'opitem:"InfluxDB" opfield:{influx_creds_section}.token' = None  # type: ignore
    influxdb_url: f'opitem:"InfluxDB" opfield:{influx_creds_section}.url' = None  # type: ignore
    weather_api_key: f'opitem:"OpenWeather" opfield:.api_key' = None  # type: ignore


# instantiate class
builtins.creds_config = CredsConfig()

from lib import app_config, \
    creds, \
    device_name_base, \
    log

from lib.process import SignalHandler
from lib import threads
from lib.threads import thread_nanny
from lib.app import AppThread
from lib.zmq import zmq_term, Closable
from lib.handler import exception_handler

from requests.adapters import ConnectionError
from requests.exceptions import RequestException

from influxdb_client import InfluxDBClient, Point
from influxdb_client.client.write_api import ASYNCHRONOUS


URL_WORKER_APP = 'inproc://app-worker'

DEFAULT_SAMPLE_INTERVAL_SECONDS = 60
ERROR_RETRY_INTERVAL_SECONDS = 5
IMPLAUSIBLE_CHANGE_PERCENTAGE = 10


def twos_complement_hex(hexval):
    bits = 16
    val = int(hexval, bits)
    if val & (1 << (bits-1)):
        val -= 1 << bits
    return val


class LoggerReader(AppThread, Closable):

    def __init__(self, field_mappings, logger_sn, logger_ip, logger_port, sample_interval_secs=DEFAULT_SAMPLE_INTERVAL_SECONDS):
        AppThread.__init__(self, name=self.__class__.__name__)
        Closable.__init__(self)

        self.processor = self.get_socket(zmq.PUSH)

        self.field_mappings = field_mappings
        self.logger_sn = logger_sn
        self.logger_ip = logger_ip
        self.logger_port = logger_port
        self.sample_interval_secs = sample_interval_secs

    def get_logger_data(self):
        output = {}

        client_socket = None
        pini = 59
        pfin = 112
        chunks = 0
        while chunks < 2:
            start = binascii.unhexlify('A5')  # start
            length = binascii.unhexlify('1700')  # datalength
            controlcode = binascii.unhexlify('1045')  # controlCode
            serial = binascii.unhexlify('0000')  # serial
            datafield = binascii.unhexlify('020000000000000000000000000000')  # com.igen.localmode.dy.instruction.send.SendDataField
            pos_ini = str(hex(pini)[2:4].zfill(4))
            pos_fin = str(hex(pfin-pini+1)[2:4].zfill(4))
            businessfield = binascii.unhexlify('0103' + pos_ini + pos_fin)  # sin CRC16MODBUS
            crc = binascii.unhexlify(str(hex(libscrc.modbus(businessfield))[4:6])+str(hex(libscrc.modbus(businessfield))[2:4]))  # CRC16modbus
            checksum = binascii.unhexlify('00')  # checksum F2
            endCode = binascii.unhexlify('15')

            inverter_sn2 = bytearray.fromhex(hex(self.logger_sn)[8:10] + hex(self.logger_sn)[6:8] + hex(self.logger_sn)[4:6] + hex(self.logger_sn)[2:4])
            frame = bytearray(start + length + controlcode + serial + inverter_sn2 + datafield + businessfield + crc + checksum + endCode)

            checksum = 0
            frame_bytes = bytearray(frame)
            for i in range(1, len(frame_bytes) - 2, 1):
                checksum += frame_bytes[i] & 255
            frame_bytes[len(frame_bytes) - 2] = int((checksum & 255))

            # OPEN SOCKET

            for res in socket.getaddrinfo(self.logger_ip, self.logger_port, socket.AF_INET, socket.SOCK_STREAM):
                family, socktype, proto, canonname, sockadress = res
                try:
                    client_socket = socket.socket(family,socktype,proto)
                    client_socket.settimeout(10)
                    client_socket.connect(sockadress)
                except socket.error as msg:
                    log.warning(f'{msg}')
                    return None

            # SEND DATA
            client_socket.sendall(frame_bytes)

            # RECEIVE RESPONSE
            try:
                data = client_socket.recv(1024)
                if data is None:
                    log.warning(f'No response data.')
                    return None
            except socket.timeout as msg:
                log.warning(f'{msg}')
                return None
            finally:
                try:
                    client_socket.close()
                except socket.error as msg:
                    log.warning(f'{msg}')

            # PARSE RESPONSE (start position 56, end position 60)
            totalpower = 0
            i = pfin - pini
            a = 0
            while a <= i:
                p1 = 56+(a*4)
                p2 = 60+(a*4)
                try:
                    response = twos_complement_hex(str(''.join(hex(ord(chr(x)))[2:].zfill(2) for x in bytearray(data))+'  '+re.sub('[^\x20-\x7f]', '', ''))[p1:p2])
                except ValueError:
                    log.warning(f'Discarding {len(data)} byte response.', exc_info=True)
                    return None
                hexpos = str("0x") + str(hex(a+pini)[2:].zfill(4)).upper()
                for parameter in self.field_mappings:
                    for item in parameter["items"]:
                        title = item["titleEN"]
                        ratio = item["ratio"]
                        unit = item["unit"]
                        for register in item["registers"]:
                            if register == hexpos and chunks != -1:
                                if title.find("Temperature") != -1:
                                    response = round(response * ratio-100, 2)
                                else:
                                    response = round(response * ratio, 2)
                                if len(unit) > 0:
                                    key = f'{title} {unit}'
                                else:
                                    key = f'{title}'
                                # sanitize string
                                key = key.replace(' ','_').replace('-','_').replace('ยบ','c').replace('%','pct').lower()
                                output[key] = response
                                if hexpos == '0x00BA':
                                    totalpower += response * ratio
                                if hexpos == '0x00BB':
                                    totalpower += response * ratio
                a+=1
            pini=150
            pfin=195
            chunks+=1
        return output

    # noinspection PyBroadException
    def run(self):
        self.processor.connect(URL_WORKER_APP)
        with exception_handler(closable=self):
            prev_battery_soc = None
            while not threads.shutting_down:
                operation_start_time = time.time()
                tries = 1
                logger_data = None
                while time.time() - operation_start_time < DEFAULT_SAMPLE_INTERVAL_SECONDS/2:
                    tries += 1
                    logger_data = self.get_logger_data()
                    if isinstance(logger_data, dict):
                        if 'battery_soc_pct' in logger_data.keys():
                            battery_soc = logger_data['battery_soc_pct']
                            if prev_battery_soc is None:
                                prev_battery_soc = battery_soc
                                # dict is good enough
                                break
                            soc_variance_pct = int(abs(((prev_battery_soc-battery_soc) / prev_battery_soc)) * 100)
                            log.debug(f'battery_soc_pct changed by {soc_variance_pct}% from {prev_battery_soc} to {battery_soc}.')
                            if soc_variance_pct >= IMPLAUSIBLE_CHANGE_PERCENTAGE:
                                log.warning(f'battery_soc_pct changed by more than {IMPLAUSIBLE_CHANGE_PERCENTAGE}% from {prev_battery_soc} to {battery_soc}. Treating this output as implausible: {str(logger_data)}')
                            else:
                                # accept the new value as good
                                prev_battery_soc = battery_soc
                                # control field change is plausible
                                break
                    log.warning(f'Waiting {ERROR_RETRY_INTERVAL_SECONDS}s after {tries} unsuccessful tries.')
                    threads.interruptable_sleep.wait(ERROR_RETRY_INTERVAL_SECONDS)
                if logger_data is not None and len(logger_data) > 0:
                    log.debug(f'Sending {len(logger_data)} fields for publication.')
                    self.processor.send_pyobj(logger_data)
                else:
                    log.error(f'Unable to fetch any valid data after {tries} tries (within {DEFAULT_SAMPLE_INTERVAL_SECONDS}s).')
                # stop for the remainder of the sampling interval
                operation_time = time.time() - operation_start_time
                sample_delay = self.sample_interval_secs - operation_time
                if sample_delay < 0:
                    normalized_sample_delay = min(operation_time, self.sample_interval_secs)
                    log.warning(f'Sample interval of {self.sample_interval_secs}s is too short, implying wait of {sample_delay:.2f}s. Resetting delay to {normalized_sample_delay:.2f}s.')
                    # don't use 0: never spin
                    sample_delay = normalized_sample_delay
                log.debug(f'Waiting {sample_delay:.2f}s until the next sample.')
                threads.interruptable_sleep.wait(sample_delay)


class WeatherReader(AppThread, Closable):

    def __init__(self):
        AppThread.__init__(self, name=self.__class__.__name__)
        Closable.__init__(self)

        self.processor = self.get_socket(zmq.PUSH)

        self.api_key = creds.weather_api_key
        self.lat, self.lon = tuple(app_config.get('weather', 'coord_lat_lon').split(','))

    def get_weather_data(self):
        output = {}
        try:
            r = requests.get('https://api.openweathermap.org/data/2.5/weather', params={
                'lat': self.lat,
                'lon': self.lon,
                'appid': self.api_key,
            })
            try:
                output = json.loads(r.content)
                log.debug(f'Loaded {len(output)} weather fields.')
            except JSONDecodeError:
                log.exception(f'JSON parse error of {r.content}')
                return None
        except (OSError, ConnectionError, RequestException):
            log.exception('Problem getting weather data.')
            return None
        return output

    # noinspection PyBroadException
    def run(self):
        log.info(f'Fetching weather data using coordinates [{self.lat},{self.lon}].')
        self.processor.connect(URL_WORKER_APP)
        with exception_handler(closable=self):
            while not threads.shutting_down:
                weather_data = self.get_weather_data()
                if weather_data is not None and len(weather_data) > 0:
                    # log.debug(f'Sending {len(weather_data)} fields for publication: {weather_data}')
                    log.info(f'Sending {len(weather_data)} fields for publication: {weather_data}')
                    # self.processor.send_pyobj(weather_data)
                threads.interruptable_sleep.wait(DEFAULT_SAMPLE_INTERVAL_SECONDS)


class EventProcessor(AppThread, Closable):

    def __init__(self):
        AppThread.__init__(self, name=self.__class__.__name__)
        Closable.__init__(self, connect_url=URL_WORKER_APP)

        self.influxdb_bucket = app_config.get('influxdb', 'bucket')

        self.influxdb = None
        self.influxdb_rw = None
        self.influxdb_ro = None

    def _influxdb_write(self, field_name, field_value):
        try:
            self.influxdb_rw.write(
                bucket=self.influxdb_bucket,
                record=Point("inverter").tag("application", app_name).tag("device", device_name_base).field(field_name, field_value))
        except Exception:
            log.warning(f'Unable to post to InfluxDB.', exc_info=True)

    # noinspection PyBroadException
    def run(self):
        # influx DB
        log.info(f'Connecting to InfluxDB at {creds.influxdb_url} using bucket {self.influxdb_bucket}.')
        self.influxdb = InfluxDBClient(
            url=creds.influxdb_url,
            token=creds.influxdb_token,
            org=creds.influxdb_org)
        self.influxdb_rw = self.influxdb.write_api(write_options=ASYNCHRONOUS)
        self.influxdb_ro = self.influxdb.query_api()
        with exception_handler(closable=self, and_raise=False, shutdown_on_error=True):
            while not threads.shutting_down:
                event = self.socket.recv_pyobj()
                log.debug(event)
                if isinstance(event, dict):
                    for key, value in event.items():
                        self._influxdb_write(key, value)
                    log.debug(f'Wrote {len(event)} points.')


if __name__ == "__main__":
    log.setLevel(logging.INFO)
    # load basic configuration
    field_mappings = None
    field_mappings_file = ''.join([os.path.join(APP_PATH, 'config', 'field_mappings.txt')])  # type: ignore
    with open(field_mappings_file) as mappings_file:
        try:
            field_mappings = json.loads(mappings_file.read())
            log.info(f'Loaded {len(field_mappings)} field mappings from {field_mappings_file}')
        except JSONDecodeError as e:
            log.exception(f'Error loading {field_mappings_file}.')
            raise e
    # ensure proper signal handling; must be main thread
    signal_handler = SignalHandler()
    event_processor = EventProcessor()
    logger_reader = LoggerReader(
        field_mappings=field_mappings,
        logger_sn=app_config.getint('inverter', 'logger_sn'),
        logger_ip=app_config.get('inverter', 'logger_address'),
        logger_port=app_config.getint('inverter', 'logger_port'),
        sample_interval_secs=app_config.getint('inverter', 'logger_sample_interval_seconds'))
    weather_reader = WeatherReader()
    nanny = threading.Thread(
        name='nanny',
        target=thread_nanny,
        args=(signal_handler,),
        daemon=True)
    # startup completed
    # back to INFO logging
    log.setLevel(logging.INFO)
    try:
        log.info('Starting application threads...')
        event_processor.start()
        logger_reader.start()
        weather_reader.start()
        # start thread nanny
        nanny.start()
        log.info('Startup complete.')
        # hang around until something goes wrong
        threads.interruptable_sleep.wait()
        raise RuntimeWarning("Shutting down...")
    except(KeyboardInterrupt, RuntimeWarning, ContextTerminated) as e:
        log.warning(str(e))
        threads.shutting_down = True
        threads.interruptable_sleep.set()
    finally:
        zmq_term()
    log.info('Shutdown complete.')
